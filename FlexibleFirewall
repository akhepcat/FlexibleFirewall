#!/bin/bash
# Initially based on "http://www.linuxhelp.net/guides/iptables/"
#    for the generic IPtables rules, as it had some nice defaults
### This script will override the defaults below with values from /etc/default/FlexibleFirewall

### BEGIN INIT INFO
# Provides:          FlexibleFirewall
# Required-Start:    mountkernfs $local_fs
# Required-Stop:     $local_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# X-Start-Before:    $network
# X-Stop-After:      $network
# Short-Description: configure iptables rules
# Description:       creates iptables rules based on simple tuples
### END INIT INFO

# TUPLES are port, IP, or IP+port pairs used to define the firewall rules.
# use the T prefix for tcp-only, U for udp only.  No prefix means both TCP and UDP
# You can specific 'I' for ICMP, and then the 'port' become the ICMP type.
#  You cannot mix ICMP and TCP/UDP on the same tuple - use separate entries.
# a suffix of 'S' will enforce the equivalent source port, which is great for DHCP rules
# A prefix of 'P' will allow the listed protocol through (such as P41, for 6in4 tunnels)
#
# IPv6 addresses should work here as well:  2000::beef:cafe;T25
# You can specify multiple-same ports or hosts for multiple rules
# prefix with an exclaimation point to negate the tuple (turn into deny)
# prefix with an @ instead of an exclaimation port for silent denies.
#
# space separated tuples to allow local services like ssh(22), smtp(25), http(80), https(443)
# note that it's easy to conflict local services with forwarded ports, so be careful.

# Apply a basic ruleset for an endpoint: Only dhcp, dns, and ssh are allowed
LOCAL_TUPLES="P41 T22 53 U67S U68S ::0/0;I129 192.168.0.0/16;I1"     # other valid tuples: "10.100.0.0/16;T443 !192.168.0.0/16"

# 1 to enable IP forwarding/NAT,  0 disables, by default
FORWARDING=1

# If forwarding is enabled, and you would like to forward specific
# ports to other machines on your home network, edit the variable below.
# They are currently set up to forward port 25 & 53 (Mail & DNS) to the example 10.1.1.51.
# Anything incoming over your $EXT_4IF through your gateway will 
# be automatically redirected invisibly to port 25 & 53 on 10.1.1.51
#
# we don't currently support ICMP forwarding, because that's weird.
#
# These will automatically generate ACCEPT rules for outbound traffic as well
# Note that these will not be applied if an internal non-default route is not found.
REMOTE_TUPLES="10.1.1.51;T25 10.1.1.51;53 10.1.1.50;2300-2400"

#NONETBIOS="true"	# null-string allows old-school "wins" netbios traffic

DEBUG="DEBUGME"	# null-string disables, non-null string enables

###########################################
#
# Functions here...

function ignore4() {
	args="$*"
	
	[[ -n "$DEBUG" ]] && lsb_msg "DEBUG: iptables ${args}"
}

function ignore6() {
	args="$*"
	
	[[ -n "$DEBUG" ]] && lsb_msg "DEBUG: ip6tables ${args}"
}

# Are we running from init?
function run_by_init() {
        if [ -n "${previous}" -a -n "${runlevel}" ]
        then
        	#running by init
                return 0
        else
        	#Not init..
                return 1
        fi
}

function decode_port() {
	# Returns the L4 port or ICMP/6 type (ready for further parsing) or null for 'any'
	local R_PORT=$1
	local S_TUPLE=$2
	local __temp=""	

#	[[ -n "$DEBUG" ]] && lsb_msg "DEBUG: decode_port(S_TUPLE)=${S_TUPLE}"

	if [ -z "${S_TUPLE##*;*}" ]	# we found an address/port pair
	then
		__temp=${TUPLE#*;}
	elif [ -n "${S_TUPLE##*/*}" -a -n "${S_TUPLE##*:*}" -a -n "${S_TUPLE##*.*}" ]
	then
		__temp=${S_TUPLE}
	fi
	

#	[[ -n "$DEBUG" ]] && lsb_msg "DEBUG: decode_port=${__temp}"
	
	eval $R_PORT="'$__temp'"
}

function decode_source() {
	# Returns the source address (ready for iptables) or null for 'any'
	local R_IP=$1
	local S_TUPLE=$2
	local __temp=""

#	[[ -n "$DEBUG" ]] && lsb_msg "DEBUG: decode_source(S_TUPLE)=${S_TUPLE}"
	
	if [ -z "${S_TUPLE##*;*}" ]	# we found an address/port pair
	then
		__temp=${S_TUPLE%;*}
	elif [ -z "${S_TUPLE##*/*}" -o -z "${S_TUPLE##*:*}" -o -z "${S_TUPLE##*.*}" ]
	then
		__temp=${S_TUPLE}
	fi
	
#	[[ -n "$DEBUG" ]] && lsb_msg "DEBUG: decode_source=${__temp}"

	eval $R_IP="'$__temp'"
}

function tuple_locals() {
	for TUPLE in $LOCAL_TUPLES
	do
		UDP=0; TCP=0; ICMP=0
		DPORT=""; SPORT=""; HOST=""; SOURCE=""; PROTO=""
		IPROTO="icmp"; ADDRFAM="-4"; ACTION="ACCEPT"
		
		[[ -z "${TUPLE##*!*}" ]] && ACTION="firewall" && TUPLE=${TUPLE//!/}
		[[ -z "${TUPLE##*@*}" ]] && ACTION="silent" && TUPLE=${TUPLE//@/}
		[[ -z "${TUPLE##*P*}" ]] && PROTO=${TUPLE//P/} && TUPLE=""
		
		decode_source SOURCE ${TUPLE}
		decode_port DPORT ${TUPLE}

		if [ -n "$DPORT" ]
		then
			[[ -z "${DPORT%%*S}" ]] && SPORT="--sport ${DPORT//[SUIT]/}" && DPORT="--dport ${DPORT//S/}"
			[[ -z "${DPORT##T*}" ]] && TCP=1 && DPORT="--dport $DPORT"
			[[ -z "${DPORT##U*}" ]] && UDP=1 && DPORT="--dport $DPORT"
			[[ -z "${DPORT##I*}" ]] && ICMP=1 && DPORT="--icmp-type $DPORT"

			if [ -n "${DPORT##*U*}" -a -n "${DPORT##*T*}" -a -n "${DPORT##*I*}" ]; then TCP=1; UDP=1; fi
		else
			# DPORT is null, so there's no service, so assume all protos
			TCP=1
			UDP=1
			ICMP=1
		fi

		DPORT=${DPORT//[SUIT]/}
		SOURCE=${SOURCE//[SUIT]/}

		if [ -n "${SOURCE}" ]
		then
			EXT_IF=$EXT_4IF
			if [ -z "${SOURCE##*:*}" ]
			then
				EXT_IF=$EXT_6IF
				FWSTACK=$IP6T
				IPROTO="ipv6-icmp"
				ADDRFAM="-6"
				DPORT=${DPORT//icmp/icmpv6}
				SOURCE=${SOURCE%/0}
			else
				FWSTACK=$IP4T
			fi

			if [ -z "$DEBUG" ]
			then
				ROUTE=$(ip ${ADDRFAM} -o route get ${SOURCE})
			else
				lsb_msg "DEBUG: ip ${ADDRFAM} -o route get ${SOURCE}"
				ROUTE="debug"
			fi
			[[ -n "${SOURCE}" ]] && SOURCE="-s ${SOURCE}"

			[[ -n "${ROUTE}" ]] && EXT_IF=${ROUTE//*dev /} && EXT_IF=${EXT_IF%% *}
			[[ $TCP -eq 1 ]] && $FWSTACK -A INPUT -i $EXT_IF ${SOURCE} -p tcp $DPORT $SPORT -j ${ACTION}
			[[ $UDP -eq 1 ]] && $FWSTACK -A INPUT -i $EXT_IF ${SOURCE} -p udp $DPORT $SPORT -j ${ACTION}
			[[ $ICMP -eq 1 ]] && $FWSTACK -A INPUT -i $EXT_IF ${SOURCE} -p ${IPROTO} $DPORT -j ${ACTION}
		else
			if [ -z "${PROTO}" ]
			then
				for FWSTACK in $IP4T $IP6T
				do
					[[ $TCP -eq 1 ]] && $FWSTACK -A INPUT -p tcp $DPORT $SPORT -j ${ACTION}
					[[ $UDP -eq 1 ]] && $FWSTACK -A INPUT -p udp $DPORT $SPORT -j ${ACTION}
					[[ $ICMP -eq 1 ]] && $FWSTACK -A INPUT -p ${IPROTO} $DPORT -j ${ACTION}
				done
			else
				$IP4T -A INPUT -p ${PROTO} -j ${ACTION}
			fi
		fi			
	done
}

function tuple_forward() {
	for TUPLE in $REMOTE_TUPLES
	do
		UDP=0; TCP=0
		DPORT=""; ADDRFAM="-4"; SOURCE=""

		ACTION="ACCEPT"
		[[ -z "${TUPLE##*!*}" ]] && ACTION="firewall" && TUPLE=${TUPLE//!/}
		[[ -z "${TUPLE##*@*}" ]] && ACTION="silent" && TUPLE=${TUPLE//@/}
		
		decode_source SOURCE ${TUPLE}
		decode_port DPORT ${TUPLE}

		if [ -n "$DPORT" ]
		then
			[[ -z "${DPORT##T*}" ]] && TCP=1
			[[ -z "${DPORT##U*}" ]] && UDP=1

			if [ -n "${DPORT##U*}" -a -n "${DPORT##T*}" ]; then TCP=1; UDP=1; fi

			DPORT=${DPORT//[TU]/}

			if [ -z "${DPORT##*-*}" ]
			then
				LPORT="--dport ${DPORT//-/:}"
				DPORT=""
			else
				LPORT="--dport $DPORT"
				DPORT=":${DPORT}"
			fi
		fi
	
		EXT_IF=$EXT_4IF
		if [ -z "${SOURCE##*:*}" ]
		then
			EXT_IF=$EXT_6IF
			FWSTACK=$IP6T
			ADDRFAM="-6"
		else
			FWSTACK=$IP4T
		fi

		if [ -z "$DEBUG" ]
		then
			ROUTE=$(ip ${ADDRFAM} -o route get ${SOURCE})
		else
			lsb_msg "DEBUG: ip ${ADDRFAM} -o route get ${SOURCE}"
			ROUTE="debug"
		fi
		if [ -n "${ROUTE##*$EXT_IF*}" -o -n "$DEBUG" ]
		then
			[[ -n "${ROUTE}" ]] && EXT_IF=${ROUTE//*dev /} && EXT_IF=${EXT_IF%% *}
			[[ $TCP -eq 1 ]] && $FWSTACK -t nat -A PREROUTING -i $EXT_IF -p tcp ${LPORT} -j DNAT --to ${SOURCE}${DPORT}
			[[ $UDP -eq 1 ]] && $FWSTACK -t nat -A PREROUTING -i $EXT_IF -p udp ${LPORT} -j DNAT --to ${SOURCE}${DPORT}
		fi
	
	done
}


function tuple_accept() {
	[[ ${FORWARDING} -ne 1 ]] && return

	for TUPLE in $REMOTE_TUPLES
	do
		ADDRFAM="-4"; SOURCE=""; DPORT=""

		decode_source SOURCE ${TUPLE}
		decode_port DPORT ${TUPLE}
	
		EXT_IF=$EXT_4IF
		if [ -z "${SOURCE##*:*}" ]
		then
			EXT_IF=$EXT_6IF
			FWSTACK=$IP6T
			DEST="::0"
			ADDRFAM="-6"
		else
			FWSTACK=$IP4T
			DEST="0/0"
		fi

		if [ -n "${SOURCE}" ]
		then
			if [ -z "$DEBUG" ]
			then
				ROUTE=$(ip ${ADDRFAM} -o route get ${SOURCE})
			else
				lsb_msg "DEBUG: ip ${ADDRFAM} -o route get ${SOURCE}"
				ROUTE="debug"
			fi
			[[ -n "${ROUTE##*$EXT_IF*}" ]] && $FWSTACK -A INPUT -s ${SOURCE} -d ${DEST}  -p all -j ACCEPT
		fi
	done
}

function stop() {
	# The following rules will clear out any existing firewall rules, 
	# and any chains that might have been created.
	for FWSTACK in $IP4T $IP6T
	do
		$FWSTACK -F
		$FWSTACK -F INPUT
		$FWSTACK -F OUTPUT
		$FWSTACK -F FORWARD
		$FWSTACK -F -t mangle
		$FWSTACK -F -t nat
		$FWSTACK -X
		$FWSTACK -P INPUT ACCEPT
		$FWSTACK -P OUTPUT ACCEPT
		$FWSTACK -P FORWARD ACCEPT
	done
}

function forwarding() {
# The following line below enables IP forwarding and thus 
# by extension, NAT. Turn this on if you're going to be 
# doing NAT or IP Masquerading.

	STATE=0
	[[ "$1" = "start" ]] && STATE=1
	
	if [ $FORWARDING -gt 0 ]
	then
		[[ -n "${IP4T##*ignore*}" ]] && echo ${STATE} > /proc/sys/net/ipv4/ip_forward || lsb_msg "DEBUG: /proc/sys/net/ipv4/ip_forward not changed"
# no such IPv6 forwarding yet.  requires additional software support
# to provide IPv6 routing, subnet delegation, etc.
#		[[ -n "${IP6T##*ignore*}" ]] && echo ${STATE} > /proc/sys/net/ipv6/ip_forward || lsb_msg "DEBUG: /proc/sys/net/ipv6/ip_forward not changed"
	fi
}

function start() {
# These will setup our policies.
	$IP4T -P INPUT DROP
	$IP6T -P INPUT DROP

	$IP4T -P OUTPUT ACCEPT
	$IP6T -P OUTPUT ACCEPT

	$IP4T -P FORWARD ACCEPT
	$IP6T -P FORWARD ACCEPT


if [ ${FORWARDING:-0} -gt 0 ]
then
	# this starts IP forwarding
	forwarding start

	# Source NAT everything heading out the $EXT_4IF (external) 
	# interface to be the given IP. If you have a dynamic IP 
	# address or a DHCP IP that changes semi-regularly, comment out 
	# the first line and uncomment the second line.
	#
	# Remember to change the ip address below to your static ip.
	#
	# $IP4T -t nat -A POSTROUTING -o $EXT_4IF -j SNAT --to 216.138.195.197
	# $IP6T -t nat -A POSTROUTING -o $EXT_6IF -j SNAT --to ${STATIC_EXT_IPv6}
	$IP4T -t nat -A POSTROUTING -o $EXT_4IF -j MASQUERADE
	$IP6T -t nat -A POSTROUTING -o $EXT_6IF -j MASQUERADE

	# This rule protects your fowarding rule.
	$IP4T -A FORWARD -i $EXT_4IF -m state --state NEW,INVALID -j DROP
	$IP6T -A FORWARD -i $EXT_6IF -m state --state NEW,INVALID -j DROP

	# set up the port forwards, if enabled
	tuple_forward
fi

# Now, our firewall chain. We use the limit commands to 
# cap the rate at which it alerts to 15 log messages per minute.
for FWSTACK in $IP4T $IP6T
do
	$FWSTACK -N firewall
	$FWSTACK -A firewall -m limit --limit 15/minute -j LOG --log-prefix Firewall:
	$FWSTACK -A firewall -j DROP

	# Now, our dropwall chain, for the final catchall filter.
	$FWSTACK -N dropwall
	$FWSTACK -A dropwall -m limit --limit 15/minute -j LOG --log-prefix Dropwall:
	$FWSTACK -A dropwall -j DROP

	# Our "hey, them's some bad tcp flags!" chain.
	$FWSTACK -N badflags
	$FWSTACK -A badflags -m limit --limit 15/minute -j LOG --log-prefix Badflags:
	$FWSTACK -A badflags -j DROP

	# And our silent logging chain.
	$FWSTACK -N silent
	$FWSTACK -A silent -j DROP
	
# Lets do some basic state-matching. This allows us 
# to accept related and established connections, so
# client-side things like ftp work properly, for example.
	$FWSTACK -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

	# This rule will accept connections from local machines.
	$FWSTACK -A INPUT -i lo -j ACCEPT
# Drop those nasty packets! These are all TCP flag 
# combinations that should never, ever occur in the
# wild. All of these are illegal combinations that 
# are used to attack a box in various ways, so we 
# just drop them and log them here.
	$FWSTACK -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j badflags
	$FWSTACK -A INPUT -p tcp --tcp-flags ALL ALL -j badflags
	$FWSTACK -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j badflags
	$FWSTACK -A INPUT -p tcp --tcp-flags ALL NONE -j badflags
	$FWSTACK -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j badflags
	$FWSTACK -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j badflags
done

# Build accept rules for all the internal tuples from the forwards
tuple_accept

# Drop icmp, but only after letting certain types through.
	$IP4T -A INPUT -p icmp --icmp-type 0 -j ACCEPT
	$IP4T -A INPUT -p icmp --icmp-type 3 -j ACCEPT
	$IP4T -A INPUT -p icmp --icmp-type 11 -j ACCEPT
	$IP4T -A INPUT -p icmp --icmp-type 8 -m limit --limit 1/second -j ACCEPT
	$IP4T -A INPUT -p icmp -j firewall

	$IP6T -A INPUT -p ipv6-icmp -m icmp6 --icmpv6-type 128 -m limit --limit 1/second -j ACCEPT
	$IP6T -A INPUT -p ipv6-icmp -m icmp6 --icmpv6-type 133 -m hl --hl-eq 255 -j ACCEPT
	$IP6T -A INPUT -p ipv6-icmp -m icmp6 --icmpv6-type 134 -m hl --hl-eq 255 -j ACCEPT
	$IP6T -A INPUT -p ipv6-icmp -m icmp6 --icmpv6-type 135 -m hl --hl-eq 255 -j ACCEPT
	$IP6T -A INPUT -p ipv6-icmp -m icmp6 --icmpv6-type 136 -m hl --hl-eq 255 -j ACCEPT
	$IP6T -A INPUT -p ipv6-icmp -j firewall

	tuple_locals

# Uncomment to drop port 137 netbios packets silently. 
# We don't like that netbios stuff, and it's way too 
# spammy with windows machines on the network.
for FWSTACK in $IP4T $IP6T
do
	if [ -n "${NONETBIOS}" ]
	then
		$FWSTACK -A INPUT -p udp --dport 135:139 -j silent
		$FWSTACK -A INPUT -p tcp --dport 135:139 -j silent
	fi

# Our final trap. Everything on INPUT goes to the dropwall 
# so we don't get silent drops.
	$FWSTACK -A INPUT -j dropwall

	EXT_IF=$EXT_4IF
	[[ -z "${FWSTACK##*6*}" ]] && EXT_IF=$EXT_6IF

# Drop some specific outbound chatter
	if [ -n "${NONETBIOS}" ]
	then
		$FWSTACK -A OUTPUT -o $EXT_IF -p udp --dport 135:139 -j silent
		$FWSTACK -A OUTPUT -o $EXT_IF -p tcp --dport 135:139 -j silent
	fi
done

	IAM=$(id -ru)
	
	if [ 1 -eq ${IAM:-0} ]
	then
		if [ -x /usr/bin/fail2ban-client ]
		then
			service fail2ban restart
		else
			[[ -n "$LOCAL_TUPLES" ]] && lsb_msg "install fail2ban to prevent brute-forcing of your local IPv4 services" >&2
		fi
	else
		[[ -n "$DEBUG" ]] && lsb_msg "DEBUG: service fail2ban restart"
	fi
}

function lsb_log_begin() {
        MSG="$*"
        run_by_init && log_action_begin_msg "${MSG}" "${PROG}" || echo "BEGIN: ${MSG}"
}

function lsb_log_end() {
        MSG="$*"
        run_by_init && log_action_end_msg "${MSG}" "${PROG}" || echo "END: ${MSG}"
}

function lsb_log_fail() {
        MSG="$*"
        run_by_init && log_failure_msg "${MSG}" "${PROG}" || echo "FAIL: ${MSG}"
}

function lsb_log_ok() {
        MSG="$*"
        run_by_init && log_success_msg "${MSG}" "${PROG}" || echo "SUCCESS: ${MSG}"
}

function lsb_msg() {
        MSG="$*"
        run_by_init && log_action_msg "${MSG}" || echo "${MSG}"
}

##########  Main starts here

# override defaults with local settings
[[ -z "$DEBUG" ]] && test -r /etc/default/FlexibleFirewall && . /etc/default/FlexibleFirewall

## for LSB init-style startup
[[ -r /lib/lsb/init-functions ]] && run_by_init && . /lib/lsb/init-functions

PROG="${0##*/}"

# The location of the ipXtables binaries file on your system.
# We try to set up equivalent IPv4 and IPv6 rules, if you've got them.
test -x /sbin/iptables${DEBUG} && IP4T="/sbin/iptables" || IP4T="ignore4"
test -x /sbin/ip6tables${DEBUG} && IP6T="/sbin/ip6tables" || IP6T="ignore6"

# The Network Interface you will be protecting. 
# this will automagically configure for your external default interface
EXT_4IF="$(awk 'BEGIN { IGNORECASE=1 } /^[a-z0-9]+[ \t]+00000000/ { print $1; exit }' /proc/net/route)"
EXT_6IF="$(awk 'BEGIN { IGNORECASE=1 } /^0+ 00 0+ 00/ && !/ffffffff/ { print $10; exit }' /proc/net/ipv6_route)"
if [ -n "$DEBUG" ]
then
	[[ -z "$EXT_4IF" ]] && EXT_4IF="debug4"
	[[ -z "$EXT_6IF" ]] && EXT_6IF="debug6"
fi

cmd=${1:-help}
cmd=${cmd,,}

FAIL2BAN=0


case ${cmd} in
        start) lsb_log_begin "starting";
	       start;
	       lsb_log_end 0;
        	;;
        stop|flush|reset) lsb_log_begin "stopping";
        		  stop;
        		  lsb_log_end 0;
        	;;
        force-reload|restart) stop; start
        	;;
        status) lsb_msg "status not implemented"
        	;;
        *) echo "${PROG} [stop|start|restart|force-reload|status]"
        	;;
esac 

exit 0
